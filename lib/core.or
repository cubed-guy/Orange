// contains all the core types

type _Ptr T
	// size = 8
	extern printf: str fmt, &T val

	fn _print: &T self
		_Ptr T.printf("%p", self)
	end
end

type u64
	// size = 8
	extern printf: str fmt, u64 d
	fn _print: u64 self
		u64.printf("%p", self)
	end

	fn _hash: u64 self -> u64
		return self
	end
end

type int
	// size = 4

	extern printf: str fmt, int d
	fn _print: int self
		int.printf("%d", self)
	end

	fn _hash: int self -> u64
		return self
	end
end

type char
	// size = 1

	extern printf: str fmt, char c
	fn _print: char self
		char.printf("%c", self)
	end

	fn _hash: int self -> u64
		return self
	end
end

type void
	// size = 0
end

type str
	let _ptr &char

	extern printf: str fmt, str s -> u64

	fn _print: str self
		str.printf("%s", self)
	end

	extern strlen: str s -> u64

	fn _hash: str self -> u64
		// hashes by xor each new character at pseudorandom positions
		// within the 64 bits of the accumulator
		// the pseudorandom positions are generated by str._hash_shuffle
		// shift can only belong in [0, 56] since shift > 56
		// would imply a byte to overflow out of the 64 bits

		let acc u64
		acc = str.strlen(self)

		return acc
		
		let shift char
		shift = str._hash_shuffle(acc, 0)

		let c char
		c = *self

		let lim int
		lim = 1000

		while c
			let block u64  // remember, this is accessible even outside
			block = shift + 0
			block = c << block
			acc = acc ^ block

			shift = str._hash_shuffle(acc, shift)
			self = self + 1
			c = *self
			print("Getting hash using ")
			println(c)

			lim = lim - 1
			if lim <= 0
				break
			end
		end

		return acc
	end

	fn _hash_shuffle: u64 acc, char shift -> char
		let mod char
		mod = acc >> shift  // previously modified byte
		shift = shift ^ mod  // use that to modify shuffle

		shift = shift & 63
		if shift <= 56
			return shift
		end

		// adjusts shift to stay <= 56
		// shifts > 56 would shift a byte outside 64 bits
		mod = mod << 3
		shift = shift ^ mod
		return shift & 63
	end

end
