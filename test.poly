// A strongly typed language with polymorphism ie templates ie generics
// This is a file demostrating the things that the compiler is capable of rn

// 'type' is just a fancier word for 'struct'
type Int_node
	let data int
	let next &Int_node
end

// Polymorphic structs don't work yet... or do they?
type Node T
	let data T
	let next &Node T

	fn nth: &Node T node, int n -> T
		while n
			node = node.next
			n = n-1
		end
		return node.data
	end

	fn _getitem: &Node T self, int n -> T
		return &Node T.nth(self, n)
	end
end

type Tree T
	let data T
	let left &Tree T
	let right &Tree T

	// 0; 1, 2; 3 4, 5 6; 7 8 9 10, 11 12 13 14

	fn nth: &Tree T node, int n -> T
		let depth int
		depth = 0
		let n2 int
		n2 = n-1
		while n2 > 0
			depth = depth + 1
			n2 = n2 >> 1
		end

		n2 = 1<<depth
		n2 = n2>>1
		n = n-1

		println(n+1)
		println(depth)
		while n2
			if n & n2
				node = node.right
				puts("RIGHT")
			else
				node = node.left
				puts("LEFT")
			end
			n2 = n2 >> 1
		end

		return node.data
	end
end

// A polymorphic function that returns the argument
fn new_thing T: T x -> T
	return x
end

// Won't work. variables of type 'any' cannot exist. '&any' variables can
// # any_cast A: A a -> any
// // println(b)
// return a

fn test_ret -> int  // syntax especially useful if not a pure function
	return 9
end

fn basics
	let a char
	a = 23

	let x int
	x = 23

	println(x)

	x = test_ret()
	println(x)

	y = a

	z = new_thing(5)

	c = 5
	c = new_thing(y)
	c = new_thing('\0')

	// Declarations can be anywhere in the function.
	// All of them have full function scope
	let y char

	let z int

	y = '9'

	z = new_thing(88)

	println(z)

	println(z)
	println(z)

	println(88)
	println(z)

	let c char
end

fn operations
	println(1+1)

	puts("Hello, World!" + 3)
	puts(3 + "Hello, World!")
end

fn control_flow
	let x int
	x = 23

	while x
		x = x - 1
		println(23-x)
	end

	x = 0

	println(x)

	while x < 25
		x = x + 1

		if x <= 15
			puts("**")

			let j char
			j = 0
			while j < 50
				print(1)
				j = j + 1
			end
			puts("")

		elif x >= 20

			print(x)
			puts(" BIGGER THAN 20")

		else

			j = 0
			while j < 3
				print(0)
				j = j + 1
			end

		end

		println(x)
	end


	x = 0
	if x == 0
		puts("ZERO")
	elif x == 1
		puts("ONE")
	elif x == 2
		puts("TWO")
	else
		puts("THREE")
	end

	x = 1
	if x == 0
		puts("ZERO")
	elif x == 1
		puts("ONE")
	elif x == 2
		puts("TWO")
	else
		puts("THREE")
	end

	x = 2
	if x == 0
		puts("ZERO")
	elif x == 1
		puts("ONE")
	elif x == 2
		puts("TWO")
	else
		puts("THREE")
	end

	x = 3

	if x == 0
		puts("ZERO")
	elif x == 1
		puts("ONE")
	elif x == 2
		puts("TWO")
	else
		puts("THREE")
	end

	x = 0
	if x == 1
		puts("ONE")
	elif x == 0
		puts("ZERO")
	end

end

fn dereffer T: &T x -> T
	return *x
end

fn pointers
	let x int
	x = 4

	let p &int

	p = &x

	println(*p)

	let g int

	x = 91
	g = dereffer(p)

	println(g)
	println(*p)

	x = 92
	g = dereffer(p)

	println(g)
	println(*p)
end

fn alloc_stuff

	let p &int

	p = alloc(int, 10)  // allocates 10 integers, returns &int based on first arg

	*p = 90

	println(*p)

	free(p)

	p = alloc(int)

	*p = 16777216

	println(*p)

	free(p)

end

fn linked_lists

	let head &Int_node
	let tail &Int_node

	tail = alloc(Int_node)
	tail.data = 5
	tail.next = 0  // unspecified type can go anywhere rn, maybe I should add Null?

	println(tail.data)

	head = tail

	tail.next = alloc(Int_node)
	tail = tail.next
	tail.data = 4
	tail.next = 0

	printaddr(head)
	printaddr(head.next)
	printaddr(tail)

	let i int
	i = 0
	while i < 10
		tail.next = alloc(Int_node)
		tail = tail.next
		tail.data = i
		i = i + 1
	end
	tail.next = 0

	let node &Int_node
	node = head
	while node
		println(node.data)
		node = node.next
	end

	node = head
	while node
		head = node.next
		printstr("Deleting ")
		printaddr(node)
		free(node)
		node = head
	end
end

fn polymorphic_structs

	let head &Node int
	let tail &Node char

	head = alloc(Node int)  // alloc needs to parse type
	head.data = 4544

	tail = alloc(Node char)
	tail.data = 89

	let s &char
	s = alloc(char, 2)
	*s = tail.data

	let s2 &char
	s2 = s + 1

	*s2 = 0

	puts(s + 0)

	println(head.data)

	// let x int
	// x = this_thing(head)

	// x = this_thing(tail)

	let node &Node int

	node = head
	head = alloc(Node int)
	head.next = node
	head.data = 55

	node = head
	head = alloc(Node int)
	head.next = node
	head.data = 77

	node = head
	head = alloc(Node int)
	head.next = node
	head.data = 99

	puts("Node data")
	node = Node_nth(head, 3)
	println(node.data)
	node = Node_nth(head, 2)
	println(node.data)
	node = Node_nth(head, 1)
	println(node.data)
	node = Node_nth(head, 0)
	println(node.data)

	// # this_thing A: A int a -> int
	// return a.data
end

fn Node_nth T: &Node T node, int n -> &Node T
	while n
		node = node.next
		n = n - 1
	end
	return node
end

fn classmethods
	let head &Node int
	let node &Node int
	node = alloc(Node int)
	head = node

	node.data = 90
	node.next = alloc(Node int)
	node = node.next

	node.data = 45
	node.next = alloc(Node int)
	node = node.next

	node.data = 22
	node.next = alloc(Node int)
	node = 0

	let a int
	a = Node int.nth(head, 2)
	println(a)


	// with trees too

	let root &Tree int
	root = alloc(Tree int)
	root.left = alloc(Tree int)
	root.right = alloc(Tree int)
	let right &Tree int
	right = root.right
	right.data = 60

	puts("calling get_nth()")
	let x int
	x = get_nth(root, 2)
	println(x)
	x = get_nth(head, 2)
	println(x)
end

fn get_nth T: T iter, int n -> int
	return T.nth(iter, n) // it'll error here if {T} not of form {A int}
end

fn array_index
	let head &Node int
	let node &Node int

	node = alloc(Node int)
	head = node

	node.data = 255000
	node.next = alloc(Node int)
	node = node.next

	node.data = 13
	node.next = alloc(Node int)
	node = node.next

	node.data = 72
	node.next = alloc(Node int)
	node = 0

	let x int
	x = head[2]
	println(x)
	
end

type Dict K V
	let cap int
	let keys &K
	let values &V
	let used int

	// So, this is a constructor? And it works? And it's in my language? Crazy!
	fn new: int cap -> &Dict K V
		let out &Dict K V
		out = alloc(Dict K V)

		out.cap = cap
		out.used = 0

		let i int

		out.keys = alloc(K, cap)
		printstr("out.keys = ")
		printaddr(out.keys)
		printstr("cap = ")
		println(cap)
		let key_ptr &K
		key_ptr = out.keys
		i = 0
		while i < cap
			*key_ptr = 0
			key_ptr = key_ptr + K:size
			i = i + 1
		end

		out.values = alloc(V, cap)
		let val_ptr &K
		val_ptr = out.keys
		i = 0
		while i < cap
			*val_ptr = 0
			val_ptr = val_ptr + V:size
			i = i + 1
		end


		return out
	end

	fn index: &Dict K V dict, K key -> int
		if dict == 0
			return 0-1
		end

		let hash int
		hash = K.hash(key)

		let cap int
		cap = dict.cap

		let index int
		index = hash % cap
		printstr("Index = ")
		println(index)
		printstr("K:size = ")
		println(K:size)

		let curr_key K
		let scaled_index int
		scaled_index = index * K:size
		let curr_key_ref &K
		curr_key_ref = dict.keys + scaled_index

		let scaled_cap int
		scaled_cap = dict.cap * K:size
		printstr("cap = ")
		println(dict.cap)
		printaddr(dict)
		printstr("size = ")
		println(K:size)
		printstr("Scaled cap = ")
		println(scaled_cap)

		// return 0-1

		let scaled_inc int
		scaled_inc = 7 * K:size

		let i int
		i = 0

		printstr("start addr of key array = ")
		printaddr(dict.keys)
		printstr("end addr of key array   = ")
		let end_addr &K
		end_addr = dict.keys + scaled_cap
		printaddr(end_addr)

		printstr("Would dereference:        ")
		// printstr("Trying to dereference: ")
		printaddr(curr_key_ref)

		let temp_key K
		temp_key = *curr_key_ref

		printaddr(temp_key)
		printaddr(*curr_key_ref)

		// compilation will fail if keys are not strings
		puts("Comparing string:")
		puts(*curr_key_ref)
		puts("vs")
		puts(key)
		puts("<End cmp args>")

		return 0-1
		// printstr("*key = ")
		// println(*temp_key + 0)
		while *curr_key_ref != 0
			printaddr(*curr_key_ref)
			return 0-1
			if *curr_key_ref == 0
				return index
			elif *curr_key_ref == key
				return index
			end

			scaled_index = scaled_index + scaled_inc
			index = index + K:size
			if scaled_index >= scaled_cap
				scaled_index = scaled_index - scaled_cap
				index = index - cap
			end
			curr_key_ref = dict.keys + scaled_index  // is this valid?
			printstr("Trying to dereference: ")
			printaddr(curr_key_ref)
			i = i + 1
			if dict.used < i
				break
			end

			printstr("DEBUG curr_key_ref            = ")
			printaddr(curr_key_ref)

			if i > 0
				printstr("DEBUG start addr of key array = ")
				printaddr(dict.keys)
				printstr("DEBUG end addr of key array   = ")
				end_addr = dict.keys + scaled_cap
				printaddr(end_addr)
				return 0-1
			end
		end
		if *curr_key_ref == key
			return index
		end
		return 0-1  // we dont have unaries yet
	end

	fn _getref: &Dict K V self, K key -> &V
		let index int
		index = Dict K V.index(self, key)
		if index < 0
			return 0
		end

		let scaled_index int
		scaled_index = index * K:size
		let key_ptr &K

		key_ptr = self.keys + scaled_index
		if *key_ptr == 0
			return 0
		end

		scaled_index = index * V:size
		return self.values + scaled_index
	end

	fn _getitem: &Dict K V self, K key -> V
		let ptr &V
		ptr = Dict K V._getref(self, key)
		if ptr == 0
			return 0
		end
		return *ptr
	end

	fn _setitem: &Dict K V self, K key, V value
		let index int
		index = Dict K V.index(self, key)
		if index < 0
			return
		end

		let scaled_index int

		let key_ptr &K
		scaled_index = index * K:size
		key_ptr = self.keys + scaled_index
		if *key_ptr == 0
			*key_ptr = key
		end

		let value_ptr &V
		scaled_index = index * V:size
		value_ptr = self.values + scaled_index
		*value_ptr = value
	end
end

fn noop A: A x -> A
	return x
end

fn dictionaries
	let dict &Dict str int
	dict = Dict str int.new(5)
	puts("DICT ADDRESSES:")
	printaddr(dict)
	printaddr(dict.keys)
	printaddr(dict.values)


	let index int
	index = Dict str int.index(dict, "new key")

	return

	println(str:size)
	println(&int:size)
	println(&Dict str int:size)

	Dict str int._setitem(dict, "new key", 5)

	let scaled_index int
	scaled_index = index * int:size
	let val_ptr &int
	val_ptr = dict.values + scaled_index

	val_ptr = &dict["new key"]
	println(*val_ptr)


	let val int
	val = dict["new key"]
	println(val)

	Dict str int._setitem(dict, "new key", 6)
	println(*val_ptr)
	Dict str int._setitem(dict, "new new key", 77)
	println(*val_ptr)

	val_ptr = &dict["new new key"]
	println(*val_ptr)

end

fn streq_tests
	puts("streq tests are running")

	if "hi" == "Hello"
		puts("hi and hello are same")
	end

	if "hi" == "hi"
		puts("hi and hi are same")
	end

	if "hi" != "Hello"
		puts("hi and hello are different")
	end

	if "hi" != "hi"
		puts("hi and hi are different")
	end
end

fn mul_tests
	println(2 * 4)
	let x int
	let y int
	x = 2
	y = 4
	println(x * y)
	println(x * Dict int int:size)

	let z int
	z = mul_sub(x, y)
	println(z)
end

fn mul_sub: int x, int y -> int
	println(x * y)
	return x * y
end

fn main
	basics()
	operations()
	control_flow()
	pointers()
	alloc_stuff()
	linked_lists()
	polymorphic_structs()
	classmethods()
	array_index()
	dictionaries()
	streq_tests()
	mul_tests()
end
